## 230320 ACID와 격리 수준

#### ACID

- A: Atomicity 원자성
  - 트랜잭션이 분할할 수 없는 단일 작업 단위로, 부분적으로 완료될 수 없다. 전부 완료되거나 전부실패되어야 한다.
  - Commit 과 Rollback으로 처리
- C: Consistency 일관성
  - 항상 일관된 상태에서 다음 상태로 이동한다. 트랜잭션이 커밋되지 않으면 트랜잭션의 변경사항은 데이터베이스에 반영되지 않는다.
  - 제약조건으로 처리
    - 개체무결성 제약조건 : PK는 not null
    - 도메인무결성 : 정의된 도메인 형식에 맞춘다
    - 참조무결성 제약조건 : 참조시 FK 이용
- I: Isolation 격리성
  - 트랜잭션의 결과는 일반적으로 트랜잭션이 완료될 때까지 다른 트랜잭션에서 보이지 않는다.
  - Lock 방식으로 처리
- D: Durability 지속성
  - 일단 커밋되면 트랜잭션의 변경 사항은 영구적이다. 시스템 충돌 시 데이터가 손실되지 않도록 변경사항을 기록해야 한다.(100프로의 지속성은 없다. ex 백업)
  - Commit 과 Rollback으로 처리

\*특히 InnoDB엔진에서 강력
<br>

#### 격리 수준

- READ UNCOMMITTED 격리 수준
  - 커밋되지 않은 트랜잭션 결과 볼 수 있음 : Dirty read
  - 성능이 좋지 않음(실제로 거의 사용되지 않음)
- READ COMMITTED 격리 수준
  - MySQL 제외한 대부분 데이터베이스 시스템의 기본 격리 수준(PG default)
  - 커밋된 트랜잭션으로 인한 변경 사항을 계속 확인할 수 있음, 커밋될 때까지 변경 사항은 다른 사람에게 표시되지 않음
  - 완료 전 다른 트랜잭션에서 조회하면 undo영역에서 백업된 데이터 가져옴
  - Nonrepeatable read : 동일한 명령문을 두 번 실행하면 다른 데이터를 볼 수 있음
- **REPEATABLE READ**
  - mongodb 최고수준의 격리 수준
  - READ COMMITTED처럼 완료 전 다른 트랜잭션에서 조회하면 undo영역에서 백업된 데이터 가져옴
  - 차이점은 백업된 레코드에서 어떤 버전(스냅샷)을 가지고 오는지가 다름
  - Phantom read 허용
  - Phantom read : 하나의 트랜잭션에서 일정 범위의 레코드를 두번이상 읽을때, 똑같은 쿼리임에도 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
  - MySQL의 InnoDB 디폴트값
- SERIALIZABLE
  - 트랜잭션에서 읽고 쓰는 레코드는 다른 트랜잭션에서 절대 접근 할 수 없음
  - 모든 행에 잠금 설정, 시간소요, 잠금 경합 발생
  - 동시성 감소(읽기 작업할 때도 Lock을 걸기 때문에)
  - 거의 사용하지 않음
