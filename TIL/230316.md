## 230316 B tree

- 데이터를 정렬하여 탐색, 삽입, 삭제 및 순차 접근이 가능하도록 유지하는 트리형 자료구조

### B-Tree

1. 노드의 자료수가 K 이라면, 자식의 수는 K + 1 개이어야 한다.
2. 자료는 정렬된 상태로 저장된다.
3. 한 노드 N 의 왼쪽 서브트리는 N의 키 작은 값으로 되어 있고, 오른쪽 서브트리는 큰 값으로 되어 있다.
4. ROOT 노드는 적어도 2개 이상의 자식을 가져야한다. ( 트리가 ROOT 노드로만 구성되어있을 경우 예외)
5. 루트 노드와 단말노드를 제외한 모든 노드가 최대 M개, 최소 [M/2] 개(올림)의 자식노드(Sub-Tree)를 가지고 있어야 한다.
6. B 트리의 장점 - 저장 장치의 효율성, 즉 각 노드마다 반 이상 키 값이 저장되어 있다.
7. 리프노드로 가는 경로의 길이는 모두 같다 = 리프노드는 모두 같은 레벨에 있다.
8. 입력 자료는 중복될 수 없다.

### B+Tree

B+트리는 크게 리프가 아닌 노드로 된 인덱스 세트와 리프 노드로만 구성된 순차 세트로 구성되어 있습니다. 인덱스 세트의 노드들은 단순히 방향을 제시하는 목적으로 사용되고, 실제 데이터들은 리프노드에 저장되며 모두 리스트로 연결되어 있습니다.

### B-tree vs B+tree

- B-tree의 각 노드에서는 key 뿐만 아니라 data도 들어갈 수 있다. B+tree는 각 node에서는 key만 들어가야 한다.
- B+tree에서는 data는 오직 leaf에만 존재한다.
- B+트리는 인덱스 노드는 데이터를 저장하지 않으므로 B-트리보다 노드 내 공간이 절약 되어 인덱스 노드에 더 많은 키 값이 저장 될 수 있어 트리 레벨이 낮아질 수 있다. 대신 검색이 항상 리프 노드까지 내려가야 만 하는 단점이 있다.
- B+트리는 마지막 리프 노드가 연결리스트로 구성되어 순차검색이 가능하다. 특정 키 값 검색과 순차 처리를 모두 필요로 하는 곳에서 효율적이다.

### B\*tree

#### B tree의 문제점

- 구조를 유지하기 위해 추가적으로 연산을 해야한다는 것(삽입시 분열하거나,삭제할때 재분배,합병)
- 각 노드는 절반 정도가 Key값으로 채워진다.

### B\*tree 특징

- Overflow 발생시 분리 대신 형제 node로 재분배 ( 중간값이 올라가는 대신 재분배)
- 형제 노드가 모두 Overflow이면 두 노드를 세 노드로 분할한다.
  - 각 노드는 결과적으로 2/3 정도가 채워진다.(기본 B-Tree의 절반정도 채워지던 것에서 2/3정도로 변화가 있다)
