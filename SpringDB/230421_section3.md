# Section3) 트랜잭션 이해

## 트랜잭션 Transaction

- 데이터베이스에서 하나의 거래를 안전하게 처리하도록 수행하는 작업의 단위

> 수진 -> 소율 5000원 계좌이체
>
> 1. 수진의 잔고를 5000원 감소
>    -> err 발생
> 2. ~~소율의 잔고를 5000원 증가~~

<br>

### ACID

- 트랜잭션 안전성을 보장하기 위해 필요한 성질

#### A tomicity 원자성

- 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.

```
ex.
트랜잭션 1 : 수진 -> 소율 5000원 계좌이체
1-1. 수진의 잔고를 5000원 감소
1-2. 소율의 잔고를 5000원 증가
```

<br>

#### C onsistency 일관성

- 일관성은 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야 한다.

```
ex.
조건 : 모든 고객은 반드시 이름을 가지고 있어야 한다(이름 NOT NULL)
- 이름 없는 새로운 고객을 추가하는 쿼리 => X
- 기존 고객의 이름을 삭제하는 쿼리 => X
```

<br>

#### I solation 격리성

- 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
- 동시에 같은 데이터를 수정하지 못하도록 한다.
- 동시에 여러 개의 트랜잭션이 실행될 때 **연속으로 실행된 것과 동일한 결과**를 나타낸다.

```
ex.
수진 잔액 10000원
1. 수진 -> 승훈 6000원 이체
2. 수진 -> 혜영 6000원 이체
```

- 1 -> 2 연속 실행: 승훈에게 6000원 이체 후 혜영에게 잔액부족으로 이체 못함
- 1, 2 동시 실행: 수진 잔액 -2000? -> 연속 실행과 동일한 결과가 나와야함!!!!
  > => _격리성은 동시성과 관련된 성능 이슈로 인해 **트랜잭션 격리 수준 제공**_

<br>

#### D urability 지속성

- 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.
  - 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

```
ex.
1. 수진 -> 준현 5000원 계좌이체 성공
    -> err : 데이터베이스 오류로 종료
2. 로그를 통해 계좌이체 내역을 확인
단, 로그 기록 전 종료되면 이체 실패 후 이전 상태로 바꿔준다
```

<br>

### 트랜잭션 격리 수준 Isolation level

- 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것\
   (격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 한다.(성능이 나쁨))
  ![image](https://user-images.githubusercontent.com/61377122/234797385-11984947-9f93-4909-8a12-4fcb608ce741.png)

#### READ UNCOMMITED

- Commit하지도 않은 걸 다른 사람이 읽을 수 있음

```
ex.
row |이수진|주임|SEED 개발팀|
승훈 |이수진|사장ㅋㅋ|SEED 개발티ㅁ|
```

트랜잭션 중 커밋도 안 했는데 수정중인 내용 그대로 다른 사람이 볼 수 있음 => `Dirty Read`
Rollback해도 이미 로직 수행중일 수 있음
=> **거의 사용하지 않음**

<br>

#### READ COMMITTED

- 그럼 Commit이 되면 읽도록 하자!

```
ex.
트랜잭션 10번 -> 수진의 나이 조회(24세)
트랜잭션 12번 -> 수진의 나이를 24세->25세 커밋
트랜잭션 10번 -> 수진의 나이 다시 조회(25세)
```

트랜잭션 10번은 하나의 트랜잭션인데, 그 안에서 다른 결과가 나옴 => `NON-REPETABLE READ`

> **_이게 왜 문제인가요?_**
> -> 오늘의 입금 총 합을 보여주는 트랜잭션이 있다고하면,
> 총합을 계산하는 SELECT 쿼리는 실행될 때 마다 다른 결과값을 가져옴
> <br>

#### REPEATABLE READ

- 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준(MySQL)
- 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(+커밋된) 것만 보게 되는 것

```
ex.
트랜잭션 10번 -> 수진의 나이 조회(24세)
트랜잭션 12번 -> 수진의 나이를 24세->25세 커밋
트랜잭션 10번 -> 수진의 나이 다시 조회(똑같이 24세)
: 해당 row의 undo 영역에 백업된 10번 시작 기준 데이터를 반환함
```

> 버전관리를 계속해야하니까 성능이슈가 있지 않나요?
> 영향 갈 정도로 트랜잭션이 오래 지속되는 경우가 많지는 않아서 READ COMMITTED와 성능 차이 크게 없음
> <br>

##### Phantom Read

```
ex.
트랜잭션 10번 -> 팀원 조회: 준현, 소율, 혜영, 승훈
트랜잭션 12번 -> INSERT 수진 + Commit
트랜잭션 10번 -> 팀원 조회: 준현, 소율, 혜영, 승훈, 수진
```

-> 한 트랜잭션 내에서 귀신처럼 없던 record가 생긴다

#### SERIALIZABLE

- Phantom Read까지 막은 격리 수준
- 읽기 작업에도 공유 잠금을 설정하게 되고, 이러면 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 된다.

- 가장 엄격하게 격리 수준을 지키지만 동시성이 너무 낮기 때문에 사용하지 않음
  ![image](https://user-images.githubusercontent.com/61377122/234797974-9217cec5-a67a-49b3-8d85-1ba037757a1a.png)

## 데이터베이스 연결 구조와 DB 세션

![image](https://user-images.githubusercontent.com/61377122/233289639-545e3165-2e6f-4143-a945-7cb961d78ecc.png)

## 트랜잭션 사용(Commit, Rollback

- commit - 데이터 변경 쿼리를 실행하고 데이터베이스에 그 결과를 반영
- rollback - 결과를 반영하고 싶지 않으면 호출

커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것이다. 따라서 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고 다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.

![image](https://user-images.githubusercontent.com/61377122/233290533-0961bff4-8aaa-420f-a8a3-15308bac81cf.png)

## 트랜잭션 - 자동 커밋, 수동 커밋

### 자동커밋

자동 커밋으로 설정하면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출한다.

```sql
set autocommit true; //자동 커밋 모드 설정
insert into member(member_id, money) values ('data1',10000); //자동 커밋
insert into member(member_id, money) values ('data2',10000); //자동 커밋
```

### 수동커밋

```sql
set autocommit false; //수동 커밋 모드 설정(트랜잭션 시작)
insert into member(member_id, money) values ('data3',10000);
insert into member(member_id, money) values ('data4',10000);
commit; //수동 커밋
```

- 원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야
  한다.

트랜잭션의 원자성 덕분에 여러 SQL 명령어를 마치 하나의 작업인 것 처럼 처리할 수 있었다. 성공하면 한번에 반영하고, 중간에 실패해도 마치 하나의 작업을 되돌리는 것 처럼 간단히 되돌릴 수 있다.

## DB 락

세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다.
![image](https://user-images.githubusercontent.com/61377122/233294156-c5490130-273a-4a63-8a74-7c8f3f55b79a.png)
![image](https://user-images.githubusercontent.com/61377122/233294365-60c1eb12-d3cf-44d5-837b-b7dff74d472a.png)
![image](https://user-images.githubusercontent.com/61377122/233294452-c04e83b0-7601-4cc0-a5bf-c36df3cf84b5.png)

- 락을 무한정 대기하는 것은 아니다.
- 락 대기 시간을 넘어가면 락 타임아웃 오류가 발생한다.
  - SET LOCK_TIMEOUT <milliseconds> : 락 타임아웃 시간을 설정한다.
  - 예) SET LOCK_TIMEOUT 10000 10초, 세션2에 설정하면 세션2가 10초 동안 대기해도 락을 얻지 못하면 락 타임아웃 오류가 발생한다.
- 락 대기 시간은 설정할 수 있다.

## DB 락 - 조회

- 데이터베이스마다 다르지만, 보통 데이터를 조회할 때는 락을 획득하지 않고 바로 데이터를 조회할 수 있다.
- 데이터를 조회할 때도 락을 획득하고 싶을 때가 있다. 이럴 때는 select for update 구문을 사용하면
  된다.

```sql
set autocommit false;
select * from member where member_id='memberA' for update;
```

> 조회 시점에 락이 필요한 경우는 언제일까?
> 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
>
> - 예를 들어서 애플리케이션 로직에서 memberA 의 금액을 조회한 다음에 이 금액 정보로 애플리케이션에서 어떤 계산을 수행한다. 그런데 이 계산이 돈과 관련된 매우 중요한 계산이어서 계산을 완료할 때 까지 memberA 의 금액을 다른곳에서 변경하면 안된다. 이럴 때 조회 시점에 락을 획득하면 된다.

## 트랜잭션 - 적용

- 애플리케이션에서 DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야한다.
  그래야 같은 세션을 사용할 수 있다.가장 단순한 방법은 커넥션을 파라미터로 전달해서 같은 커넥션이 사용되도록 유지하는 것이다.
  ![image](https://user-images.githubusercontent.com/61377122/233309126-86440c82-d05c-46fb-ba55-d6849a1bdbde.png)
