# Section3) 트랜잭션 이해

## 트랜잭션

- 데이터베이스에서 하나의 거래를 안전하게 처리하도록 보장해주는 것
  > ex. 수진 -> 소율 5000원 계좌이체
  >
  > 1. 수진의 잔고를 5000원 감소
  >    -> err 발생
  > 2. ~~소율의 잔고를 5000원 증가~~

### ACID

- 트랜잭션은 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 보장해야 한다는 원칙

- 원자성(Atomicity): 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.
  일관성(Consistency): 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
- 격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준
  (Isolation level)을 선택할 수 있다.
- 지속성(Durability): 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

### 트랜잭션 격리 수준 - Isolation level

격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 한다. 이렇게 하면 동시 처리 성능이 매우 나빠진다.

- READ UNCOMMITED(커밋되지 않은 읽기)
- READ COMMITTED(커밋된 읽기)
- REPEATABLE READ(반복 가능한 읽기)
- SERIALIZABLE(직렬화 가능)

## 데이터베이스 연결 구조와 DB 세션

![image](https://user-images.githubusercontent.com/61377122/233289639-545e3165-2e6f-4143-a945-7cb961d78ecc.png)

## 트랜잭션 사용(Commit, Rollback

- commit - 데이터 변경 쿼리를 실행하고 데이터베이스에 그 결과를 반영
- rollback - 결과를 반영하고 싶지 않으면 호출

커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것이다. 따라서 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고 다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.

![image](https://user-images.githubusercontent.com/61377122/233290533-0961bff4-8aaa-420f-a8a3-15308bac81cf.png)

## 트랜잭션 - DB 예제2 - 자동 커밋, 수동 커밋

### 자동커밋

자동 커밋으로 설정하면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출한다.

```sql
set autocommit true; //자동 커밋 모드 설정
insert into member(member_id, money) values ('data1',10000); //자동 커밋
insert into member(member_id, money) values ('data2',10000); //자동 커밋
```

### 수동커밋

자동 커밋 모드에서 수동 커밋 모드로 전환 하는 것을 트랜잭션을 시작한다고 표현한다.

```sql
set autocommit false; //수동 커밋 모드 설정
insert into member(member_id, money) values ('data3',10000);
insert into member(member_id, money) values ('data4',10000);
commit; //수동 커밋
```

- 원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야
  한다.

트랜잭션의 원자성 덕분에 여러 SQL 명령어를 마치 하나의 작업인 것 처럼 처리할 수 있었다. 성공하면 한번에 반영하고, 중간에 실패해도 마치 하나의 작업을 되돌리는 것 처럼 간단히 되돌릴 수 있다.

## DB 락

세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다.
![image](https://user-images.githubusercontent.com/61377122/233294156-c5490130-273a-4a63-8a74-7c8f3f55b79a.png)
![image](https://user-images.githubusercontent.com/61377122/233294365-60c1eb12-d3cf-44d5-837b-b7dff74d472a.png)
![image](https://user-images.githubusercontent.com/61377122/233294452-c04e83b0-7601-4cc0-a5bf-c36df3cf84b5.png)

- 락을 무한정 대기하는 것은 아니다.
- 락 대기 시간을 넘어가면 락 타임아웃 오류가 발생한다.
  - SET LOCK_TIMEOUT <milliseconds> : 락 타임아웃 시간을 설정한다.
  - 예) SET LOCK_TIMEOUT 10000 10초, 세션2에 설정하면 세션2가 10초 동안 대기해도 락을 얻지 못하면 락 타임아웃 오류가 발생한다.
- 락 대기 시간은 설정할 수 있다.

## DB 락 - 조회

- 데이터베이스마다 다르지만, 보통 데이터를 조회할 때는 락을 획득하지 않고 바로 데이터를 조회할 수 있다.
- 데이터를 조회할 때도 락을 획득하고 싶을 때가 있다. 이럴 때는 select for update 구문을 사용하면
  된다.

```sql
set autocommit false;
select * from member where member_id='memberA' for update;
```

> 조회 시점에 락이 필요한 경우는 언제일까?
> 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
>
> - 예를 들어서 애플리케이션 로직에서 memberA 의 금액을 조회한 다음에 이 금액 정보로 애플리케이션에서 어떤 계산을 수행한다. 그런데 이 계산이 돈과 관련된 매우 중요한 계산이어서 계산을 완료할 때 까지 memberA 의 금액을 다른곳에서 변경하면 안된다. 이럴 때 조회 시점에 락을 획득하면 된다.

## 트랜잭션 - 적용

- 애플리케이션에서 DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야한다.
  그래야 같은 세션을 사용할 수 있다.가장 단순한 방법은 커넥션을 파라미터로 전달해서 같은 커넥션이 사용되도록 유지하는 것이다.
  ![image](https://user-images.githubusercontent.com/61377122/233309126-86440c82-d05c-46fb-ba55-d6849a1bdbde.png)
